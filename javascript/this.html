<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.32">
    <link rel="shortcut icon" href="/favicons/favicon.ico"><title>this | dailyuno Tech Blog</title><meta name="description" content="">
    <link rel="modulepreload" href="/assets/app.49c6a941.js"><link rel="modulepreload" href="/assets/this.html.91d55eb9.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/this.html.09d90eae.js">
    <link rel="stylesheet" href="/assets/style.b5235dab.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">dailyuno Tech Blog</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><a href="/html/tags.md" class="sidebar-item sidebar-heading" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/html/tags.html" class="sidebar-item" aria-label="태그"><!--[--><!--]--> 태그 <!--[--><!--]--></a><!----></li><li><a href="/html/semantic-tags.html" class="sidebar-item" aria-label="시맨틱 태그"><!--[--><!--]--> 시맨틱 태그 <!--[--><!--]--></a><!----></li><li><a href="/html/attributes.html" class="sidebar-item" aria-label="속성"><!--[--><!--]--> 속성 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/css/flex.md" class="sidebar-item sidebar-heading" aria-label="CSS"><!--[--><!--]--> CSS <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/css/flex.html" class="sidebar-item" aria-label="Flex"><!--[--><!--]--> Flex <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/javascript/scope.md" class="sidebar-item sidebar-heading active" aria-label="Javascript"><!--[--><!--]--> Javascript <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/javascript/event-loop.html" class="sidebar-item" aria-label="이벤트 루프"><!--[--><!--]--> 이벤트 루프 <!--[--><!--]--></a><!----></li><li><a href="/javascript/queues.html" class="sidebar-item" aria-label="큐의 종류"><!--[--><!--]--> 큐의 종류 <!--[--><!--]--></a><!----></li><li><a href="/javascript/prototype.html" class="sidebar-item" aria-label="프로토타입"><!--[--><!--]--> 프로토타입 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/javascript/this.html" class="router-link-active router-link-exact-active router-link-active sidebar-item active" aria-label="this"><!--[--><!--]--> this <!--[--><!--]--></a><!----></li><li><a href="/javascript/scope.html" class="sidebar-item" aria-label="스코프"><!--[--><!--]--> 스코프 <!--[--><!--]--></a><!----></li><li><a href="/javascript/hoisting.html" class="sidebar-item" aria-label="호이스팅"><!--[--><!--]--> 호이스팅 <!--[--><!--]--></a><!----></li><li><a href="/javascript/XMLHttpRequest.html" class="sidebar-item" aria-label="XMLHTTPRequest"><!--[--><!--]--> XMLHTTPRequest <!--[--><!--]--></a><!----></li><li><a href="/javascript/IndexedDB.html" class="sidebar-item" aria-label="IndexedDB"><!--[--><!--]--> IndexedDB <!--[--><!--]--></a><!----></li><li><a href="/javascript/localStorage.html" class="sidebar-item" aria-label="localStorage"><!--[--><!--]--> localStorage <!--[--><!--]--></a><!----></li><li><a href="/javascript/promise.html" class="sidebar-item" aria-label="Promise"><!--[--><!--]--> Promise <!--[--><!--]--></a><!----></li><li><a href="/javascript/iteration-protocols.html" class="sidebar-item" aria-label="이터레이션 프로토콜"><!--[--><!--]--> 이터레이션 프로토콜 <!--[--><!--]--></a><!----></li><li><a href="/javascript/generator.html" class="sidebar-item" aria-label="제너레이터"><!--[--><!--]--> 제너레이터 <!--[--><!--]--></a><!----></li><li><a href="/javascript/async-await.html" class="sidebar-item" aria-label="Async &amp; Await"><!--[--><!--]--> Async &amp; Await <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/typescript/init.md" class="sidebar-item sidebar-heading" aria-label="Typescript"><!--[--><!--]--> Typescript <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/typescript/init.html" class="sidebar-item" aria-label="시작하기"><!--[--><!--]--> 시작하기 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-annotation.html" class="sidebar-item" aria-label="타입 어노테이션"><!--[--><!--]--> 타입 어노테이션 <!--[--><!--]--></a><!----></li><li><a href="/typescript/primitive-types.html" class="sidebar-item" aria-label="원시 타입"><!--[--><!--]--> 원시 타입 <!--[--><!--]--></a><!----></li><li><a href="/typescript/special-types.html" class="sidebar-item" aria-label="특수 타입"><!--[--><!--]--> 특수 타입 <!--[--><!--]--></a><!----></li><li><a href="/typescript/array-tuple.html" class="sidebar-item" aria-label="배열과 튜플"><!--[--><!--]--> 배열과 튜플 <!--[--><!--]--></a><!----></li><li><a href="/typescript/enum.html" class="sidebar-item" aria-label="열거형"><!--[--><!--]--> 열거형 <!--[--><!--]--></a><!----></li><li><a href="/typescript/enum-issue.html" class="sidebar-item" aria-label="열거형의 문제점"><!--[--><!--]--> 열거형의 문제점 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-alias.html" class="sidebar-item" aria-label="타입 별칭"><!--[--><!--]--> 타입 별칭 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-assertion.html" class="sidebar-item" aria-label="타입 단언"><!--[--><!--]--> 타입 단언 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-guard.html" class="sidebar-item" aria-label="타입 가드"><!--[--><!--]--> 타입 가드 <!--[--><!--]--></a><!----></li><li><a href="/typescript/unions-and-intersections.html" class="sidebar-item" aria-label="유니온과 교차 타입"><!--[--><!--]--> 유니온과 교차 타입 <!--[--><!--]--></a><!----></li><li><a href="/typescript/interface.html" class="sidebar-item" aria-label="인터페이스"><!--[--><!--]--> 인터페이스 <!--[--><!--]--></a><!----></li><li><a href="/typescript/generic.html" class="sidebar-item" aria-label="제네릭"><!--[--><!--]--> 제네릭 <!--[--><!--]--></a><!----></li><li><a href="/typescript/class.html" class="sidebar-item" aria-label="클래스"><!--[--><!--]--> 클래스 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-compatibility.html" class="sidebar-item" aria-label="타입 호환성"><!--[--><!--]--> 타입 호환성 <!--[--><!--]--></a><!----></li><li><a href="/typescript/type-relationship.html" class="sidebar-item" aria-label="타입 간의 관계"><!--[--><!--]--> 타입 간의 관계 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/react/init.md" class="sidebar-item sidebar-heading" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/react/init.html" class="sidebar-item" aria-label="시작하기"><!--[--><!--]--> 시작하기 <!--[--><!--]--></a><!----></li><li><a href="/react/context-api.html" class="sidebar-item" aria-label="Context API"><!--[--><!--]--> Context API <!--[--><!--]--></a><!----></li><li><a href="/react/higher-order-component.html" class="sidebar-item" aria-label="고차 컴포넌트"><!--[--><!--]--> 고차 컴포넌트 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/react/hooks/init.md" class="sidebar-item sidebar-heading" aria-label="React Hooks"><!--[--><!--]--> React Hooks <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/react/hooks/init.html" class="sidebar-item" aria-label="Hooks이란?"><!--[--><!--]--> Hooks이란? <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-state.html" class="sidebar-item" aria-label="useState"><!--[--><!--]--> useState <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-effect.html" class="sidebar-item" aria-label="useEffect"><!--[--><!--]--> useEffect <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-context.html" class="sidebar-item" aria-label="useContext"><!--[--><!--]--> useContext <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-ref.html" class="sidebar-item" aria-label="useRef"><!--[--><!--]--> useRef <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-memo.html" class="sidebar-item" aria-label="useMemo"><!--[--><!--]--> useMemo <!--[--><!--]--></a><!----></li><li><a href="/react/hooks/use-callback.html" class="sidebar-item" aria-label="useCallback"><!--[--><!--]--> useCallback <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/redux/init.md" class="sidebar-item sidebar-heading" aria-label="Redux"><!--[--><!--]--> Redux <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/redux/init.html" class="sidebar-item" aria-label="시작하기"><!--[--><!--]--> 시작하기 <!--[--><!--]--></a><!----></li><li><a href="/redux/connect.html" class="sidebar-item" aria-label="connect"><!--[--><!--]--> connect <!--[--><!--]--></a><!----></li><li><a href="/redux/use-dispatch.html" class="sidebar-item" aria-label="useDispatch"><!--[--><!--]--> useDispatch <!--[--><!--]--></a><!----></li><li><a href="/redux/use-selector.html" class="sidebar-item" aria-label="useSelector"><!--[--><!--]--> useSelector <!--[--><!--]--></a><!----></li><li><a href="/redux/reselect.html" class="sidebar-item" aria-label="reselect"><!--[--><!--]--> reselect <!--[--><!--]--></a><!----></li><li><a href="/redux/redux-thunk.html" class="sidebar-item" aria-label="redux-thunk"><!--[--><!--]--> redux-thunk <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/web-technology/browser-render.md" class="sidebar-item sidebar-heading" aria-label="Web Technology"><!--[--><!--]--> Web Technology <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/web-technology/browser-render.html" class="sidebar-item" aria-label="브라우저 렌더링"><!--[--><!--]--> 브라우저 렌더링 <!--[--><!--]--></a><!----></li><li><a href="/web-technology/cors.html" class="sidebar-item" aria-label="CORS"><!--[--><!--]--> CORS <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/computer-science/functional-programming.md" class="sidebar-item sidebar-heading" aria-label="Computer Science"><!--[--><!--]--> Computer Science <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/computer-science/functional-programming.html" class="sidebar-item" aria-label="함수형 프로그래밍"><!--[--><!--]--> 함수형 프로그래밍 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="들어가며" tabindex="-1"><a class="header-anchor" href="#들어가며" aria-hidden="true">#</a> 들어가며</h2><p>자바스크립트에서는 이벤트를 처리하거나 객체의 프로퍼티 값을 변경할 때 <code>this</code> 키워드를 사용해본 경험이 있을 거다. 하지만 <code>this</code>가 어떻게 생기는지, 왜 값이 달라지는지에 대해서는 설명하기 어려울 수 있다. <code>this</code>에 대해 자세히 알아보는 시간을 가지려고 한다.</p><h2 id="this란" tabindex="-1"><a class="header-anchor" href="#this란" aria-hidden="true">#</a> this란?</h2><p>자바스크립트에서 <code>this</code>는 자바와 같은 언어의 <code>this</code>와는 다르게 작동한다. 자바에서 <code>this</code>는 자기 자신 인스턴스를 가리키는 참조 변수로 쓰인다.</p><p>하지만 자바스크립트에서 <code>this</code>는 함수를 호출하는 방법에 의해서 값이 결정되는데, 자기 자신을 가리키는 것은 아니다. 어디서 선언되었는지가 중요한게 아니라 함수가 어디서 호출 됐는지에 따라 참조하는 값이 달라진다.</p><p>간단하게 <code>this</code>에 대해 요약을 해보자면 다음과 같다.</p><ul><li>별다른 선언 없이 암묵적으로 생성된다.</li><li>함수 호출 시, 암묵적으로 전달 받는다.</li><li>위치에 제약을 받지 않고, 어디에서나 사용할 수 있다.</li></ul><p><code>this</code>의 추상적인 내용들에 대해서만 설명했는데, 어떤 값을 참조하는지 알기 위해서는 다음 규칙들을 알아야 한다.</p><ol><li>기본 바인딩</li><li>암시적 바인딩</li><li>명시적 바인딩</li><li>New 바인딩</li><li>이벤트 바인딩</li></ol><h2 id="기본-바인딩" tabindex="-1"><a class="header-anchor" href="#기본-바인딩" aria-hidden="true">#</a> 기본 바인딩</h2><p>기본 바인딩은 다른 바인딩 규칙들에 해당하지 않을 경우, 기본적으로 적용되는 것을 의미한다. 아래 코드를 보면 <code>this</code>는 함수 내부가 아니더라도 사용할 수 있으며, 콘솔을 통해 출력해보면 <code>window</code> 객체가 나오는 걸 확인할 수 있다. 즉 <code>this</code>는 <code>window</code> 객체가 기본 바인딩 된다는 것을 알 수 있다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>그리고 신기하게도 전역 함수를 만들거나 var를 통해서 전역 변수를 선언하면 동일한 이름의 전역 객체 프로퍼티가 만들어진다. 다음과 같이 함수 내부에서 <code>this</code>를 통해서 참조할 수 있다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> blog <span class="token operator">=</span> <span class="token string">&quot;dailyuno&quot;</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>blog <span class="token operator">===</span> blog<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blog <span class="token operator">===</span> blog<span class="token punctuation">)</span> <span class="token comment">// true</span>

<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>blog<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// dailyuno</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="암시적-바인딩" tabindex="-1"><a class="header-anchor" href="#암시적-바인딩" aria-hidden="true">#</a> 암시적 바인딩</h2><p>암시적 바인딩에서는 객체의 메소드인지를 확인한다. 다음과 같이 user 객체가 있고 print라는 메소드를 가진다고 가정해보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  <span class="token function-variable function">print</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">은 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">살입니다.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// user1은 20살입니다.</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

user<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>print 메소드에서는 user 객체의 프로퍼티를 사용하고 있는데, 이는 user 객체가 print 메소드를 소유한다고 보고, print 메소드 호출 시 user 객체가 <code>this</code>에 바인딩 되기 때문이다.</p><p>그럼 다음과 같이 user 객체가 또 다른 객체인 friend를 프로퍼티로 가지고, friend 객체가 print 메소드를 가지는 경우엔 어떻게 작동할까?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  friend<span class="token operator">:</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;friend1&quot;</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>
    <span class="token function-variable function">print</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">은 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">살입니다.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

user<span class="token punctuation">.</span>friend<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>실행 결과는 print 메소드를 friend가 소유한다고 보고, friend 객체가 <code>this</code>에 바인딩 되며, friend의 프로퍼티 값이 출력된다. 물론 user 객체도 friend 객체를 가지고 있으니, print 메소드를 소유한다고 볼 수도 있지만 <code>this</code>에 바인딩 되는 것은 직접적으로 메소드를 소유하고 있는 friend 객체다.</p><p>이제 함수를 외부에서 선언하고, 객체에서는 참조하기만 할 경우 어떻게 작동하는지를 알아보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">은 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">살입니다.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// user1은 20살입니다.</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
  print<span class="token operator">:</span> print<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

user<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>print 메소드를 실행해보면 알겠지만 객체가 메소드를 직접 소유하지 않고 있는데, 객체는 <code>this</code>에 바인딩 된다. 즉 객체는 메소드를 직접적으로 소유하지 않고 참조만 하더라도, 메소드 호출 시 객체를 <code>this</code>에 바인딩 한다는 것을 알 수 있다.</p><h2 id="명시적-바인딩" tabindex="-1"><a class="header-anchor" href="#명시적-바인딩" aria-hidden="true">#</a> 명시적 바인딩</h2><p>암시적 바인딩에서는 객체를 <code>this</code>에 바인딩하기 위해, 메소드를 소유하거나 참조가 필요하다. 그런데 객체를 다른 곳에서 사용해야 하는 상황이 생길 수도 있는데, 이 때 명시적 바인딩이 필요하다.</p><p>명시적 바인딩은 <code>call</code>과 <code>apply</code> 그리고 <code>bind</code> 메소드를 사용해야 한다. <code>call</code>과 <code>apply</code>는 사용법이 유사한데, 바인딩 할 객체를 첫 번째 인자로 넘긴다.</p><p>다음 예제를 통해 알아보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">은 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">살입니다.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user2&quot;</span><span class="token punctuation">,</span>
  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// user1 객체를 바인딩한다.</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// user2 객체를 바인딩한다.</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>위 코드는 <code>call</code>과 <code>apply</code>를 사용해서 print 함수를 호출할 때 <code>this</code>에 각각 user1과 user2 객체를 바인딩하여 호출한다. 이렇게 단순히 바인딩할 객체만 넘길 경우에는 <code>call</code>과 <code>apply</code>는 차이가 없으므로, 넘어가도 무방하다.</p><p>그리고 <code>call</code>과 <code>apply</code>는 다음과 같이 객체가 아닌 값을 바인딩할 수 있다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Number {1}</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// String {&#39;a&#39;}</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Boolean {true}</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Window</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// []</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>특이한 점은 <code>Number</code>, <code>String</code>, <code>Boolean</code>, <code>BigInt</code> 원시 값을 전달할 경우, 해당하는 객체의 인스턴스로 생성되어 <code>this</code>에 바인딩 되고, <code>null</code>과 <code>undefined</code>는 인자로 넘길 경우, <code>window</code> 객체가 <code>this</code>에 바인딩 된다는 점이다. 이 외의 값들은 따로 변경되지 않고 바인딩이 이루어진다.</p><p>이제 <code>bind</code> 메소드는 어떻게 바인딩을 하는지 알아보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> bindPrint <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">bindPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// user 객체</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><code>bind</code> 메소드는 함수를 호출할 때마다 바인딩할 객체를 넘겨주는 <code>call</code>과 <code>apply</code> 메소드와는 다르다. 바인딩할 객체를 넘겨주는 것은 동일하지만 함수가 실행되는 것은 아니며, 새로운 함수를 반환한다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> user1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user1&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> user2 <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token string">&quot;user2&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> bindPrint1 <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bindPrint2 <span class="token operator">=</span> <span class="token function">print</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bindPrint3 <span class="token operator">=</span> <span class="token function">bindPrint1</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">bindPrint3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 여전히 user1 객체가 this에 바인딩 된다.</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>새롭게 바인딩 된 함수는 여러 개를 만들 수 있으며, 각기 다른 용도로 사용할 수 있다. 하지만 한 번 바인딩 된 함수는 다음과 같이 여러 번 바인딩을 할 수 없다. 뿐만 아니라 <code>bind</code> 메소드를 통해 만들어진 함수는 <code>call</code>과 <code>apply</code>를 통해 바인딩할 객체를 넘겨주더라도 무시된다.</p><h2 id="new-바인딩" tabindex="-1"><a class="header-anchor" href="#new-바인딩" aria-hidden="true">#</a> New 바인딩</h2><p><code>new</code> 연산자를 사용해 객체를 만들 수 있다. <code>new</code> 연산자로 새롭게 생성된 객체는 함수 내부에 암묵적으로 빈 객체 <code>{}</code>를 만들고, <code>this</code>에 바인딩한다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// User {}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// User {}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>위 코드와 같이, <code>new</code> 연산자로 만든 객체는 빈 User 객체가 <code>this</code>에 바인딩된 것을 볼 수 있다. 바인딩 된 객체의 이름은 함수의 이름과 동일하며, 함수에서 따로 반환하지 않더라도 <code>this</code>를 반환한다.</p><p>그럼 값을 반환할 경우, 어떤 값이 반환될까?</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// User {}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><code>new</code> 연산자로 만든 객체는 함수 내부에서 값을 반환하더라도, 반환한 값이 원시 값일 경우 무시하고 <code>this</code>를 반환한다.</p><p>명시적으로 값을 반환하고 싶은 경우에는 다음과 같이 원시 값이 아닌, 객체를 반환해야 한다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;new user&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// { name: &#39;new user&#39; }</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="이벤트-바인딩" tabindex="-1"><a class="header-anchor" href="#이벤트-바인딩" aria-hidden="true">#</a> 이벤트 바인딩</h2><p>먼저 이벤트 바인딩에 대해 알기 위해서는 이벤트 처리에 대한 이해가 필요하다. 예를 들어, 클릭과 같은 이벤트를 처리하기 위해서는 다음과 같이 <code>addEventListener</code>를 통해, 등록하고자 하는 DOM에 이벤트 리스너를 등록해야 한다.</p><p>이벤트 리스너의 등록 방법은 다음과 같다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>document
  <span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 클릭 시 실행 */</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>이벤트가 발생했을 때, 이벤트를 처리하는 함수를 이벤트 핸들러라고 하는데, 이벤트 핸들러에서는 이벤트가 발생한 요소가 <code>this</code>에 바인딩 된다.</p><p>여기서 요소는 핸들러에 전달된 이벤트 객체의 <code>currentTarget</code> 프로퍼티와 동일하다.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>document
  <span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// body</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>currentTarget <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="바인딩-우선순위" tabindex="-1"><a class="header-anchor" href="#바인딩-우선순위" aria-hidden="true">#</a> 바인딩 우선순위</h2><p>지금까지 함수를 호출할 때 <code>this</code> 바인딩 규칙에 대해 알아보았다. 그런데 여러 개의 규칙이 중복될 경우, 어떤 규칙이 먼저 적용될까? 궁금증을 해결하기 위해, 어떤 규칙이 우선순위로 적용되는지 알아보자.</p><p>암시적 바인딩과 명시적 바인딩은 앞서 설명했던 것처럼 명시적 바인딩이 우선시되므로 생략하겠다.</p><h3 id="이벤트-바인딩-vs-암시적-바인딩" tabindex="-1"><a class="header-anchor" href="#이벤트-바인딩-vs-암시적-바인딩" aria-hidden="true">#</a> 이벤트 바인딩 vs 암시적 바인딩</h3><p>먼저 이벤트 바인딩과 암시적 바인딩은 어떤게 우선적으로 적용되는지 알아보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">onClick</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// body</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>currentTarget <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

document
  <span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> handler<span class="token punctuation">.</span>onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>객체 내부에서 선언한 메소드를 이벤트 핸들링 함수로 넘기면 body 영역을 클릭했을 때 <code>this</code>에는 body가 출력된다. 즉 이벤트 바인딩이 암시적 바인딩보다 우선시 된다는 것을 알 수 있다.</p><h3 id="이벤트-바인딩-vs-명시적-바인딩" tabindex="-1"><a class="header-anchor" href="#이벤트-바인딩-vs-명시적-바인딩" aria-hidden="true">#</a> 이벤트 바인딩 vs 명시적 바인딩</h3><p>그럼 이벤트 바인딩은 명시적 바인딩 보다 우선시될까? 미리 만들어둔 <code>onClick</code> 메소드에 빈 객체를 bind하고, body 영역을 클릭해보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">onClick</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>currentTarget <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">)</span>  <span class="token comment">// false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

document
  <span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&quot;body&quot;</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> handler<span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>body 영역을 클릭하면 <code>this</code>에는 빈 객체가 바인딩되어 콘솔에 <code>{}</code>와 false가 출력된다. 명시적 바인딩은 이벤트 바인딩보다 우선순위가 높음을 알 수 있다.</p><h3 id="new-바인딩-vs-명시적-바인딩" tabindex="-1"><a class="header-anchor" href="#new-바인딩-vs-명시적-바인딩" aria-hidden="true">#</a> New 바인딩 vs 명시적 바인딩</h3><p>new 바인딩과 명시적 바인딩은 어느쪽이 우선순위가 높은지 알아보자. <code>call</code>과 <code>apply</code>를 통해서는 비교가 어려우니 <code>bind</code> 메소드를 통해, 새로운 함수를 만들고 new 연산자로 객체를 생성해서 비교해보자.</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">post</span><span class="token punctuation">(</span><span class="token parameter">title</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> postObj1 <span class="token operator">=</span> <span class="token punctuation">{</span>content<span class="token operator">:</span> <span class="token string">&quot;empty&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> bindPost <span class="token operator">=</span> <span class="token function">post</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>postObj1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">bindPost</span><span class="token punctuation">(</span><span class="token string">&quot;테스트1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> postObj2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">bindPost</span><span class="token punctuation">(</span><span class="token string">&quot;테스트2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>postObj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {content: &quot;empty&quot;, title: &#39;테스트1&#39;}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>postObj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// post {title: &#39;테스트2&#39;}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><code>bind</code> 메소드로 만든 <code>bindPost</code> 함수는 호출하면 content 프로퍼티를 가지게 된다. 하지만 new 연산자를 통해 객체를 생성하면 content 프로퍼티가 사라지는 것을 볼 수 있다. 이를 통해 new 바인딩은 모든 바인딩 규칙 중에서 제일 우선순위가 높다는 것을 알 수 있다.</p><h3 id="우선순위-정리" tabindex="-1"><a class="header-anchor" href="#우선순위-정리" aria-hidden="true">#</a> 우선순위 정리</h3><ol><li>new 연산자로 함수를 호출했는가?</li></ol><ul><li>새롭게 생성된 객체가 <code>this</code>에 바인딩 된다.</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> card <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Card</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Card {} === this (true)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ol start="2"><li>call과 apply로 함수를 호출하거나 bind를 통해 새로운 함수를 만들어 호출했는가?</li></ol><ul><li>인자로 넘긴 객체가 <code>this</code>에 바인딩 된다.</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj === this (true)</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj === this (true)</span>
<span class="token function">print</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// obj === this (true)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="3"><li>이벤트 핸들러로 호출됐는가?</li></ol><ul><li>이벤트가 발생한 요소가 <code>this</code>에 바인딩 된다.</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span> <span class="token comment">// document.body === this (true)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li>객체 내부에 있는 메소드인가?</li></ol><ul><li>해당 객체가 <code>this</code>에 바인딩 된다.</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">print</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// obj === this (true)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="5"><li>그 외의 경우에는 기본값이 바인딩 된다.</li></ol><ul><li>윈도우 객체가 <code>this</code>에 바인딩 된다.</li></ul><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window === this (true)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 34119537+dailyuno@users.noreply.github.com">dailyuno</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"><a href="/javascript/prototype.html" class="" aria-label="프로토타입"><!--[--><!--]--> 프로토타입 <!--[--><!--]--></a></span><span class="next"><a href="/javascript/scope.html" class="" aria-label="스코프"><!--[--><!--]--> 스코프 <!--[--><!--]--></a></span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.49c6a941.js" defer></script>
  </body>
</html>
